---
title: "HW1"
output:
  html_document:
    self_contained: yes
---
## **https://github.com/mephisto1202/STATS-506.git**
## **Problem 1 - Abalone Data**

1.1

```{r}
#' Step 1: Read the raw data from the CSV file.
abalone <- read.csv("abalone.data", header = FALSE) 
#' Step 2: Define the correct column names.
column_names <- c( "Sex", "Length", "Diameter", "Height", "Whole_weight", "Shucked_weight", "Viscera_weight", "Shell_weight", "Rings" ) 
#' Step 3: Assign the defined names to the data frame's columns.
colnames(abalone) <- column_names 
#' Step 4: Display the first few rows to verify the data was loaded correctly.
head(abalone)
```

1.2

```{r}
#' Step 1: Use table() to calculate number in different sex.
sex_counts <- table(abalone$Sex)
#' Step 2: Use print to output the data.
print(sex_counts)
```

1.3

```{r}
#'Step 1: Calculate different weights' correlation with rings.
whole_weight_cor <- cor(abalone$Whole_weight, abalone$Rings)
shucked_weight_cor <- cor(abalone$Shucked_weight, abalone$Rings)
viscera_weight_cor <- cor(abalone$Viscera_weight, abalone$Rings)
shell_weight_cor <- cor(abalone$Shell_weight, abalone$Rings)
#'Step 2: Put the value and the name in a group,which can help us compare later.
group1 <- c(
  "Whole_weight" = cor(abalone$Whole_weight, abalone$Rings),
  "Shucked_weight" = cor(abalone$Shucked_weight, abalone$Rings),
  "Viscera_weight" = cor(abalone$Viscera_weight, abalone$Rings),
  "Shell_weight" = cor(abalone$Shell_weight, abalone$Rings)
)
#'Step 3: Compare the value and get the max value and its name.
highest_corr <- which.max(abs(group1))
cat("the weight which has the highest correlation with rings is:", names(highest_corr), "\n")
#'Step 1: Separate the data into different sex groups.
abalone_F <- subset(abalone, Sex == "F")
abalone_I <- subset(abalone, Sex == "I")
abalone_M <- subset(abalone, Sex == "M")
highest_corr_name <-names(highest_corr)
#'Step 2: Calculate the different correlation.
cor_F <- cor(abalone_F[,names(highest_corr)], abalone_F$Rings)
cor_I <- cor(abalone_I[,names(highest_corr)], abalone_I$Rings)
cor_M <- cor(abalone_M[,names(highest_corr)], abalone_M$Rings)

#'Step 3: Compare by the sex.
group2 <- c(
  "F" = cor_F,
  "I" = cor_I,
  "M" = cor_M
)
highest_sex <- which.max(abs(group2))
cat("the sex has the highest correlation is:", names(highest_sex), "\n")
#'Step 1: Find the max ring.
max_rings <- max(abalone$Rings)
#'Step 2: Find the data with the max ring.
max_rings_data <- abalone[abalone$Rings == max_rings, ]
#'Step 3: Print.
cat("the weights of the abalone with the most rings are:")
print(max_rings_data[, c("Whole_weight", "Shucked_weight", "Viscera_weight", "Shell_weight")])
percentage <- sum(abalone$Viscera_weight > abalone$Shell_weight) / nrow(abalone) * 100
cat("the percentage of abalones have a viscera weight larger than their shell weight is:", round(percentage, 2), "%\n")
```

## **Problem 2 - Food Expenditure Data**

2.1

```{r}
#' import data
food_data <- read.csv("food_expenditure.csv", header = TRUE)
```

2.2

```{r}
#'Step 1: Simplify the name.
new_column_names <- c(
  "id", "age", "household_size", "state", "currency",
  "total_expenditure", "grocery_expenditure", "dining_out_expenditure",
  "misc_expenditure", "dining_out_times", "incl_alcohol", "food_assistance"
)
#' Step 2: Replace the name.
colnames(food_data) <- new_column_names
#' Step 3: Check the name.
names(food_data)
```

2.3

```{r}
#' Step 1: Show the counts before restrict.
cat("Before:", nrow(food_data), "\n")
#' Step 2: restrict to USD.
food_data_usd <- subset(food_data, currency == "USD")
#' Step 3: Show the counts after restrict.
cat("After:", nrow(food_data_usd), "\n")
```

2.4

```{r}
cleaned_food_data <- food_data_usd
#' Step 1: Show the lines before cleaning.
cat("Before:", nrow(cleaned_food_data), "\n")
#' Step 2: Clean the data age under 18.
cleaned_food_data <- subset(cleaned_food_data, age >= 18)
cat("After(age):", nrow(cleaned_food_data), "\n")
#' Step 3: Clean the data state that is none.
cleaned_food_data <- subset(cleaned_food_data, state != "" & state != "None")
cat("Afer(state):", nrow(cleaned_food_data), "\n")
#' Step 4: Clean the data expenditure is negative.
cleaned_food_data <- subset(cleaned_food_data, total_expenditure >= 0 & 
                                  grocery_expenditure >= 0 & 
                                  dining_out_expenditure >= 0 & 
                                  misc_expenditure >= 0)
cat("Afer(expenditure):", nrow(cleaned_food_data), "\n")
#' Step 5: Clean the data out times is over 21(because people only eat 21 times in a week).
cleaned_food_data <- subset(cleaned_food_data, dining_out_times <= 21)
cat("After(out times):", nrow(cleaned_food_data), "\n")
cat("--- Final repoert ---\n")
cat("After all clean,the counts are:", nrow(cleaned_food_data), "\n")
head(cleaned_food_data)
```

## **Problem 3 - Collatz conjecture**

3.1

```{r}
#' Compute the next number in a Collatz sequence.
#' This function takes a positive integer and applies the Collatz conjecture rules:
#' if the number is even, it divides it by 2; if it's odd, it multiplies it by 3 and adds 1.
#' @param n A single positive integer.
#' @return A positive integer representing the next number in the Collatz sequence.
#' @examples
#' nextCollatz(5)
#' nextCollatz(16)
#' @export
nextCollatz <- function(n) {
  #' Step 1: Check if n is a single positive integer.
  if (length(n) != 1 || !is.numeric(n) || n <= 0 || n %% 1 != 0) {
    stop("Input must be a single positive integer.")
  }

  #' Step 2: Use the Collatz rules.
  if (n %% 2 == 0) {
    return(n / 2)
  } 
  else {
    return(3 * n + 1)
  }
}
cat("nextCollatz(5) = ", nextCollatz(5), "\n")
cat("nextCollatz(16) = ", nextCollatz(16), "\n")
```

3.2

```{r}
#' Generate a Collatz sequence.
#' This function computes the complete Collatz sequence for a given positive integer,
#' starting at the input and ending at 1. It uses the nextCollatz function
#' to perform the step-by-step calculation.
#' @param n A single positive integer.
#' @return A list containing two elements:
#'   - `sequence`: A numeric vector of the entries in the Collatz sequence.
#'   - `length`: An integer representing the length of the sequence.
#' @examples
#' collatzSequence(5)
#' collatzSequence(19)
#' @export
collatzSequence <- function(n) {
  #' Step 1: Check if n is a single positive integer
  if (length(n) != 1 || !is.numeric(n) || n <= 0 || n %% 1 != 0) {
    stop("Input must be a single positive integer.")
  }
  current_number <- n
  sequence <- c(n)
  while (current_number != 1) {
    current_number <- nextCollatz(current_number)
    sequence <- c(sequence, current_number)
  }
  return(list(
    sequence = sequence,
    length = length(sequence)
  ))
}
cat("collatzSequence(5) =")
print(collatzSequence(5)$sequence)
cat("\ncollatzSequence(19) =")
print(collatzSequence(19)$sequence)
```

3.3

```{r}
#' Use Collatz sequence to find the shortest and longest sequence.
#' Use virable to save the information about thelongest and shortest sequence.
shortest_length <- Inf
shortest_start <- NA
longest_length <- 0
longest_start <- NA

#' Step 1: Use a loop to experience all number between 100 and 500.
for (i in 100:500) {
  #' Step 2: Use if to judge whether need to update the longest or shortest sequence.
  sequence_info <- collatzSequence(i)
  current_length <- sequence_info$length
  if (current_length < shortest_length) {
    shortest_length <- current_length
    shortest_start <- i
  }
  if (current_length > longest_length) {
    longest_length <- current_length
    longest_start <- i
  }
}
cat("--- Final Report ---\n")
cat("shortest:\n")
cat("start:", shortest_start, "\n")
cat("length:", shortest_length, "\n")
cat("\n")
cat("longest:\n")
cat("start:", longest_start, "\n")
cat("length:", longest_length, "\n")
```
